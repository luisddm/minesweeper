{"name":"Minesweeper","tagline":"The classic game implemented with JQuery","body":"# Minesweeper (Buscaminas)\r\n\r\nEsta es una implementación del clásico Buscaminas. A continuación una explicación del algoritmo tanto para situar las minas y los números que indican el número de minas alrededor como para descubrirlas en función de los eventos del jugador.\r\n\r\nLa versión actual se puede ver en funcionamiento en [Codepen](http://codepen.io/luisddm/pen/KwaLPv).\r\n\r\n**ATENCIÓN: esta versión del juego y de la documentación es preliminar y está en fase intensiva de desarrollo. Ver al final de este documento la lista de [cosas por hacer](#to-do-list).**\r\n\r\n## Información general\r\n\r\nEsta implementación se ha hecho utilizando algunas características interesantes de JQuery. La principal de ellas es aprovechar el método [`.data()`](http://api.jquery.com/data/) para almacenar datos arbitrarios en cualquier elemento del DOM. Usaremos esto para almacenar el cada casilla el estado actual de la misma.\r\n\r\n## Generación del tablero\r\n\r\nA continuación se describe el proceso para generar el tablero de juego y dejarlo preparado para empezar a jugar.\r\n\r\n### Colocación de las minas\r\n\r\nNecesitamos generar dos números aleatorios tantas veces como el número de minas que tengamos que colocar. Estos dos números indicarán la posición de la mina respecto a los ejes x e y. Si en la posición en cuestión no hay ninguna mina, la colocamos ahí e incrementamos el contador. Si ya hay una mina, ignoramos esta posición y dejamos el contador igual. Este proceso terminará cuando el contador alcance el número de minas a colocar.\r\n\r\nEs importante reseñar que todos los índices de las casillas y el tablero (y lo mismo para contadores de cualquier tipo) empiezan en 0 y acaban en *longitud-1*.\r\n\r\n```\r\nn = 0\r\nmientras n < núm de minas\r\n\tx = núm aleatorio entre 0 y xTablero-1\r\n\ty = núm aleatorio entre 0 y yTablero-1\r\n\r\n\tcelda = localización del elemento del DOM que representa la celda en el tablero usando x e y\r\n\r\n\tsi no hay una mina ya colocada en esta celda\r\n\t\tcolocar aquí una mina\r\n\t\tincrementar n\r\n```\r\n\r\n### Colocación de los números\r\n\r\nDe lo que se trata aquí es de colocar en cada casilla que no tenga una mina un número que indique la cantidad de minas que hay a su alrededor. En principio se considerarán las ocho casillas circundantes, es decir, superior, inferior, derecha, izquierda y las cuatro esquinas.\r\n\r\nDebemos iterar cada una de las casillas del tablero, buscando una por una cuántas minas hay en sus ocho posiciones adyacentes. Este será el número que contendrá la casilla. Si no hay minas adyacentes, la casilla queda en blanco. Hay que tener cuidado, ya que una casilla situada en una esquina o un borde del tablero no tendrá ocho casillas adyacentes, sino tres o cinco, respectivamente.\r\n\r\n```\r\npara cada celda\r\n\tk = 0\r\n\tsi no hay una mina\r\n\t\tsi la celda de la derecha existe y es una mina\r\n\t\t\tincrementar k\r\n\t\tsi la celda de la izquierda existe y es una mina\r\n\t\t\tincrementar k\r\n\t\tsi la celda superior existe y es una mina\r\n\t\t\tincrementar k\r\n\t\tsi la celda inferior existe y es una mina\r\n\t\t\tincrementar k\r\n\t\tsi la celda de la esquina superior derecha existe y es una mina\r\n\t\t\tincrementar k\r\n\t\tsi la celda de la esquina superior izquierda existe y es una mina\r\n\t\t\tincrementar k\r\n\t\tsi la celda de la esquina inferior derecha existe y es una mina\r\n\t\t\tincrementar k\r\n\t\tsi la celda de la esquina inferior izquierda existe y es una mina\r\n\t\t\tincrementar k\r\n\tsi k > 0 asignar este número a la celda\r\n\tsi k sigue siendo 0 dejar la casilla en blanco\r\n```\r\n\r\n### Implementación\r\n\r\nLa forma de asignar un cierto dato a un elemento del DOM sin que el usuario lo pueda ver es mediante el método `.data()`, como ya hemos dicho antes. De este modo cada casilla tendrá dos posibles claves para el atributo *data*.\r\n\r\nclave | posibles valores | descripción\r\n:---: | :---: | ---\r\nrevealed | *true* o *false* | Denota si el contenido de la celda ha sido mostrado al jugador o no.\r\nmines | número entero (0...8) | Número de minas que hay alrededor de una casilla. El 0 denota que se trata de una mina. Si está vacío o no existe significa que no hay minas alrededor.\r\n\r\n## Descubrimiento de las celdas\r\n\r\nUna vez que el tablero está listo y con todos los elementos colocados, se procede a descubrir las casillas correspondientes por cada click del usuario.\r\n\r\n### Click en una celda\r\n\r\nLa única interacción real del jugador con el tablero es el click en una celda, luego debemos asignar un evento de tipo *onclick* a cada una de ellas. Una vez producido este evento, pueden ocurrir tres cosas distintas, en función de lo que contiene:\r\n\r\n- Si se trata de una mina, el juego termina y el jugador pierde. Todas las minas del tablero aparecen en sus respectivas posiciones y éste queda bloqueado hasta el siguiente juego.\r\n- Si se trata de un número, se muestra el número sin más.\r\n- Si se trata de un espacio vacío es porque no hay ninguna mina en las celdas circundantes. Entonces se descubre el contenido de esta celda y también el de todas las adyacentes. Sin embargo, este caso es el más complicado, ya que si alguna de estas celdas es otro espacio vacío, también habrá que mostrar a su vez todas sus celdas circundantes, y así hasta que no quede ninguna celda vacía alrededor de las que se van mostrando.\r\n\r\n```\r\nclick en celda\r\n   si es una mina\r\n      mostrar todas las minas\r\n      bloquear tablero\r\n   si es un número\r\n      mostrar este número\r\n   si es un espacio vacío\r\n      mostrar esta celda y todas las adyacentes, si están ocultas\r\n      si alguna celda adyacente está vacía\r\n         mostrar esta celda y todas las adyacentes, si están ocultas\r\n         ...\r\n            (hasta que no queden celdas vacías adyacentes sin mostrar)\r\n```\r\n\r\n#### Celda vacía\r\n\r\nEn el caso de que hagamos click en una celda vacía, y a su vez haya celdas vacías a su alrededor, y así sucesivamente, debemos usar un algoritmo iterativo que es más complejo que un simple bucle. La técnica que usaremos aquí es la siguiente:\r\n\r\n- Usamos una función que recibe como entrada una celda, y devuelve un array con las coordenadas de las celdas vacías a su alrededor.\r\n\r\n```\r\nceldasVacias = array unidimensional\r\nsi la celda de la derecha existe, es una celda vacía y está sin descubrir\r\n\tañado sus coordenadas a celdasVacias\r\nsi la celda de la izquierda existe, es una celda vacía y está sin descubrir\r\n\tañado sus coordenadas a celdasVacias\t\r\nsi la celda superior existe, es una celda vacía y está sin descubrir\r\n\tañado sus coordenadas a celdasVacias\r\nsi la celda inferior existe, es una celda vacía y está sin descubrir\r\n\tañado sus coordenadas a celdasVacias\r\nsi la celda de la esquina superior derecha existe, es una celda vacía y está sin descubrir\r\n\tañado sus coordenadas a celdasVacias\r\nsi la celda de la esquina superior izquierda existe, es una celda vacía y está sin descubrir\r\n\tañado sus coordenadas a celdasVacias\r\nsi la celda de la esquina inferior derecha existe, es una celda vacía y está sin descubrir\r\n\tañado sus coordenadas a celdasVacias\r\nsi la celda de la esquina inferior izquierda existe, es una celda vacía y está sin descubrir\r\n\tañado sus coordenadas a celdasVacias\r\n```\r\n\r\n- Partimos de un array bidimiensional vacío f[]. Tras la primera iteración, almacenará las coordenadas de las celdas vacías a su alrededor en f[0][0...n].\r\n- Para cada una de estas celdas buscamos a su vez sus celdas adyacentes, siempre que no hayan sido descubiertas ya, y las almacenamos en f[1][0...n].\r\n- Repetimos esto n veces hasta que el array resultante esté vacío.\r\n\r\n## TO-DO LIST\r\n\r\n- Descripción más detallada del algoritmo para descubrir las celdas.\r\n- Mejora de características de usabilidad (reiniciar juego, etc.).\r\n- Mejora de la hoja de estilos.\r\n- Implementación de el evento click derecho para marcar las celdas donde el jugador cree que hay una mina.\r\n- Reconocer la situación en la que el jugador ha ganado. Hasta ahora no existe el evento como tal.\r\n- English version.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}